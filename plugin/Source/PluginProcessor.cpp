/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
StageDirectorAudioProcessor::StageDirectorAudioProcessor() : inputBuffer(2,1), outputBuffer(2,1)
{
    centFile = "~/StageDirector/centroid.txt";
    levelFile = "~/StageDirector/level.text";
    centFile.deleteFile();
    centInStream = centFile.createInputStream();
    centOutStream = centFile.createOutputStream();
    levelFile = "~/StageDirector/level.txt";
    levelFile.deleteFile();
    levelInStream = centFile.createInputStream();
    levelOutStream = centFile.createOutputStream();
    fftSelectedSize_ = 2048;
    hopSelectedSize_ = hopSizeActual_ = 1024;
    windowType_ = kHamming;
    centroid_ = 0.0f;
    level_ = 0.0f;
    
    FFTFlag_ = false;
    transformSize_ = 0;
    inputBufferLength_ = 1;
    outputBufferLength_ = 1;
    inputBufferWritePosition_ = outputBufferReadPosition_ = outputBufferWritePosition_ = 0;
    samplesSinceFFT_ = 0;
    windowBuffer_ = 0;
    windowBufferLength_ = 0;
    preparedFlag_ = false;
    lastUIHeight_ = 400;
    lastUIWidth_ = 400;
    
}

StageDirectorAudioProcessor::~StageDirectorAudioProcessor()
{
    deinitFFT();
    deinitWindow();
}

//==============================================================================
const String StageDirectorAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int StageDirectorAudioProcessor::getNumParameters()
{
    return kNumParams;
}

float StageDirectorAudioProcessor::getParameter (int index)
{
    switch (index) {
        case kMasterBypass: return (float)BypassFlag_;
        case kFFTSize: return fftSelectedSize_;
        case kHopSize: return hopSelectedSize_;
        case kWindowType: return windowType_;
        case kCentroid: return centroid_;
        case kLevel: return level_;
        default: return 0.0f;
    }
}

void StageDirectorAudioProcessor::setParameter (int index, float newValue)
{
    switch (index) {
        case kMasterBypass:
            if((bool)newValue!=BypassFlag_)
            {
                BypassFlag_ = (bool)newValue;
            }
            break;
        case kFFTSize:
            if((int)newValue != fftSelectedSize_)
            {
                fftSelectedSize_ = (int) newValue;
                if(preparedFlag_)
                {
                    initFFT(fftSelectedSize_);
                    initWindow(fftSelectedSize_, windowType_);
                }
            }
            break;
        case kHopSize:
            hopSelectedSize_ = (int)newValue;
            if(preparedFlag_)
                updateHopSize();
            break;
        case kWindowType:
            if((int)newValue != windowType_)
            {
                windowType_ = (int)newValue;
                if(preparedFlag_)
                    initWindow(transformSize_, (int)newValue);
            }
            break;
        case kCentroid:
            if(newValue != centroid_)
            {
                centroid_ = newValue;
            }
        case kLevel:
            if(newValue != level_)
            {
                level_ = newValue;
            }
        default:
            break;
    }
}

const String StageDirectorAudioProcessor::getParameterName (int index)
{
    switch (index)
    {
        case kMasterBypass: return "Bypass";
        case kFFTSize:      return "FFT size";
        case kHopSize:      return "Hop size";
        case kWindowType:   return "Window type";
        case kCentroid:     return "Spectral Centroid";
        case kLevel:    return "Average Level";
        default:               break;
    }
    
    return String::empty;
}

const String StageDirectorAudioProcessor::getParameterText (int index)
{
    return String (getParameter (index), 2);return String();
}

const String StageDirectorAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String StageDirectorAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool StageDirectorAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool StageDirectorAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool StageDirectorAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool StageDirectorAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool StageDirectorAudioProcessor::silenceInProducesSilenceOut() const
{
#if JucePlugin_SilenceInProducesSilenceOut
    return true;
#else
    return false;
#endif
}

double StageDirectorAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int StageDirectorAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int StageDirectorAudioProcessor::getCurrentProgram()
{
    return 0;
}

void StageDirectorAudioProcessor::setCurrentProgram (int index)
{
}

const String StageDirectorAudioProcessor::getProgramName (int index)
{
    return String();
}

void StageDirectorAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void StageDirectorAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    
    initFFT(fftSelectedSize_); //Initialise FFT
    initWindow(fftSelectedSize_, windowType_); //Initialise window function
    samplerate_ = (int)sampleRate; //Import samplerate
    if(!centFile.existsAsFile()){
        preparedFlag_ = false;
    }
    else{
    preparedFlag_ = true; //Ready to use
    }
}

void StageDirectorAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
    
    deinitFFT();
    deinitWindow();
    preparedFlag_ = false;
}

void StageDirectorAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    const int numInputChannels = getNumInputChannels();
    const int numOutputChannels = getNumOutputChannels();
    const int numSamples = buffer.getNumSamples();
    centroid_ = 0.0f;
    level_ = 0.0f;
    float weighted = 0.0;    //Weighted frequency bin magnitude
    float mag = 0.0;           //Frequency bin magnitude
    float frequencyScaler = (float)samplerate_/transformSize_;   //Frequency jump (Hz) between bins
    
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = numInputChannels; i < numOutputChannels; ++i)
        buffer.clear (i, 0, buffer.getNumSamples());
    
    
        int channel, inWrite, outRead, outWrite, samplesSinceFFT;
        
        fftSpinLock_.enter(); //enter spinlock, prevent fft settings from changing
        
        if(!FFTFlag_){ //if not initialised, set a;; outputs to 0 and return
            for(channel = 0; channel < numOutputChannels; ++channel)
            {
                buffer.clear(channel, 0, buffer.getNumSamples());
            }
            
            fftSpinLock_.exit();
            return;
        }
        
        //For each input channel, collect samples in input buffer, and at hop interval calculate fft
        for(channel = 0; channel < numInputChannels; ++channel)
        {
            //Array holding smaples for channel
            float*  channelData = buffer.getWritePointer(channel);
            
            float* inputBufferData = inputBuffer.getWritePointer(jmin(channel, inputBuffer.getNumChannels()-1));
            float* outputBufferData = outputBuffer.getWritePointer(jmin(channel, inputBuffer.getNumChannels()-1));
            
            inWrite = inputBufferWritePosition_;
            outRead = outputBufferReadPosition_;
            outWrite = outputBufferWritePosition_;
            samplesSinceFFT = samplesSinceFFT_;
            
            for(int i = 0; i < numSamples; ++i)
            {
                const float in = channelData[i];
                level_ += (float)abs(in)/numSamples;
                
                // Store next sample in output buffer. Done first to avoid
                // overwriting previous fft data
                channelData[i] = outputBufferData[outRead];
                outputBufferData[outRead] = 0.0;
                if(++outRead >= outputBufferLength_)
                    outRead = 0;
                
                //Current sample goes to input buffer, increment write pointer and
                //samples since last FFT. If samples since equals hopsize, perform
                //fft.
                
                inputBufferData[inWrite] = in;
                if(++inWrite >= inputBufferLength_)
                    inWrite = 0;
                if(++samplesSinceFFT >= hopSizeActual_)
                {
                    samplesSinceFFT = 0;
                    
                    //Find starting position
                    int inputBufferStartPos = (inWrite + inputBufferLength_ - transformSize_) % inputBufferLength_;
                    //Window buffer, then copy into input
                    int inputBufferPos = inputBufferStartPos;
                    for(int fftBufferPos = 0; fftBufferPos < transformSize_; fftBufferPos++)
                    {
                        timeDomain[fftBufferPos][1] = 0.0; //Imaginary section 0
                        if(fftBufferPos >= windowBufferLength_)
                            timeDomain[fftBufferPos][0] = 0.0;
                        else
                            timeDomain[fftBufferPos][0] = windowBuffer_[fftBufferPos] * inputBufferData[inputBufferPos];
                        inputBufferPos++;
                        if(inputBufferPos >= inputBufferLength_)
                            inputBufferPos = 0;
                    }
                    
                    fftw_execute(forwardPlan);
                    
                    for(int bin = 1; bin < transformSize_; bin++)
                    {
                        float amplitude  = sqrt(frequencyDomain[bin][0]*frequencyDomain[bin][0] + frequencyDomain[bin][1]*frequencyDomain[bin][1]);
                        
                        frequencyDomain[bin][0] = amplitude; //real part, amp
                        frequencyDomain[bin][1] = 0.0; //imaginary part, phase
                        
                        //first part of centroid calculation
                        weighted += bin * frequencyScaler * frequencyDomain[bin][0];
                        mag += frequencyDomain[bin][0];
                    }
                    centroid_ = (weighted/mag)/10000.0f;
                    
                    //Output Buffer manipulation
                     
                     int outputBufferPos = outWrite;
                     for(int fftBufferPos = 0; fftBufferPos < transformSize_; fftBufferPos++)
                     {
                     // Reapply the window since phase changes will result in discontinities at the edges
                     // of the window
                     if(fftBufferPos < windowBufferLength_)
                     outputBufferData[outputBufferPos] += windowBuffer_[fftBufferPos] *
                     timeDomain[fftBufferPos][0];
                     if(++outputBufferPos >= outputBufferLength_)
                     outputBufferPos = 0;
                     }
                     
                     // Advance the write position within the buffer by the hop size
                     outWrite = (outWrite + hopSizeActual_) % outputBufferLength_;
                    
                    
                }
                
                
            }
            
            
            
        }
        centFile.replaceWithText(String(centroid_));
        //convert level value into dB
        level_ = 20*log10(level_*1000);
        levelFile.replaceWithText(String(level_));
        //Persistance of variables
        inputBufferWritePosition_ = inWrite;
        outputBufferReadPosition_ = outRead;
        outputBufferWritePosition_ = outWrite;
        samplesSinceFFT_ = samplesSinceFFT;
        fftSpinLock_.exit();
}

//==============================================================================
bool StageDirectorAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* StageDirectorAudioProcessor::createEditor()
{
    return new StageDirectorAudioProcessorEditor (*this);
}

//==============================================================================
void StageDirectorAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    
    XmlElement root("Root");
    XmlElement *el;
    el = root.createNewChildElement("FFTSize");
    el->addTextElement(String(transformSize_));
    el = root.createNewChildElement("HopSize");
    el->addTextElement(String(hopSizeActual_));
    el = root.createNewChildElement("WindowType");
    el->addTextElement(String(windowType_));
    copyXmlToBinary(root, destData);
    
}

void StageDirectorAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    
    XmlElement* pRoot = getXmlFromBinary(data, sizeInBytes);
    if(pRoot!=NULL)
    {
        forEachXmlChildElement((*pRoot), pChild)
        {
            if(pChild->hasTagName("FFTSize"))
            {
                String text = pChild->getAllSubText();
                setParameter(kFFTSize, text.getFloatValue());
            }
            else if(pChild->hasTagName("HopSize"))
            {
                String text = pChild->getAllSubText();
                setParameter(kHopSize, text.getFloatValue());
            }
            else if(pChild->hasTagName("WindowType"))
            {
                String text = pChild->getAllSubText();
                setParameter(kWindowType, text.getFloatValue());
            }
        }
    }
}

void StageDirectorAudioProcessor::initFFT(int length)
{
    if(FFTFlag_)
        deinitFFT();
    
    // Save the current length so we know how big our results are later
    transformSize_ = length;
    
    // Here we allocate the complex-number buffers for the FFT. This uses
    // a convenient wrapper on the more general fftw_malloc()
    timeDomain = fftw_alloc_complex(length);
    frequencyDomain = fftw_alloc_complex(length);
    
    // FFTW_ESTIMATE doesn't necessarily produce the fastest executing code (FFTW_MEASURE
    // will get closer) but it carries a minimum startup cost. FFTW_MEASURE might stall for
    // several seconds which would be annoying in an audio plug-in context.
    forwardPlan = fftw_plan_dft_1d(transformSize_, timeDomain,
                                       frequencyDomain, FFTW_FORWARD, FFTW_ESTIMATE);
    
    // Allocate the buffer that the samples will be collected in
    inputBufferLength_ = transformSize_;
    inputBuffer.setSize(2, inputBufferLength_);
    inputBuffer.clear();
    inputBufferWritePosition_ = 0;
    samplesSinceFFT_ = 0;
    
    // Allocate the output buffer to be twice the size of the FFT
    // This will be enough for all hop size cases
    outputBufferLength_ = 2*transformSize_;
    outputBuffer.setSize(2, outputBufferLength_);
    outputBuffer.clear();
    outputBufferReadPosition_ = 0;
    
    updateHopSize();
    
    FFTFlag_ = true;
}

// Free the FFT data structures
void StageDirectorAudioProcessor::deinitFFT()
{
    if(!FFTFlag_)
        return;
    
    // Prevent this variable from changing while an audio callback is running.
    // Once it has changed, the next audio callback will find that it's not
    // initialised and will return silence instead of attempting to work with the
    // (invalid) FFT structures. This produces an audible glitch but no crash,
    // and is the simplest way to handle parameter changes in this example code.
    fftSpinLock_.enter();
    FFTFlag_ = false;
    fftSpinLock_.exit();
    
    fftw_destroy_plan(forwardPlan);
    fftw_free(timeDomain);
    fftw_free(frequencyDomain);
    
    // Leave the input buffer in memory until the plugin is released
}

//==============================================================================
// Create a new window of a given length and type
void StageDirectorAudioProcessor::initWindow(int length, int windowType)
{
    if(windowBuffer_ != 0)
        deinitWindow();
    if(length == 0) // Sanity check
        return;
    
    // Allocate memory for the window
    windowBuffer_ = (double *)malloc(length * sizeof(double));
    
    // Write the length as a double here to simplify the code below (otherwise
    // typecasts would be wise)
    double windowLength = length;
    
    // Set values for the window, depending on its type
    for(int i = 0; i < length; i++)
    {
        // Window functions are typically defined to be symmetrical. This will cause a
        // problem in the overlap-add process: the windows instead need to be periodic
        // when arranged end-to-end. As a result we calculate the window of one sample
        // larger than usual, and drop the last sample. (This works as long as N is even.)
        // See Julius Smith, "Spectral Audio Signal Processing" for details.
        switch(windowType)
        {
            case kBartlett:
                windowBuffer_[i] = (2.0/(windowLength + 2.0))*
                (0.5*(windowLength + 2.0) - abs((double)i - 0.5*windowLength));
                break;
            case kHann:
                windowBuffer_[i] = 0.5*(1.0 - cos(2.0*M_PI*(double)i/windowLength));
                break;
            case kHamming:
                windowBuffer_[i] = 0.54 - 0.46*cos(2.0*M_PI*(double)i/windowLength);
                break;
            case kRect:
            default:
                windowBuffer_[i] = 1.0;
                break;
        }
    }
    
    windowBufferLength_ = length;
}

// Free the window buffer
void StageDirectorAudioProcessor::deinitWindow()
{
    if(windowBuffer_ == 0)
        return;
    
    // Delay clearing the window until the audio thread is not running
    // to avoid a crash if the code tries to access an invalid window
    fftSpinLock_.enter();
    windowBufferLength_ = 0;
    fftSpinLock_.exit();
    
    free(windowBuffer_);
    windowBuffer_ = 0;
}

// Update the actual hop size depending on the window size and hop size settings
// Hop size is expressed as a fraction of a window in the parameters.
void StageDirectorAudioProcessor::updateHopSize()
{
    hopSizeActual_ = hopSelectedSize_;
    
    // Read pointer lags the write pointer to allow for FFT buffers to accumulate and
    // be processed. Total latency is sum of the FFT size and the hop size.
    outputBufferWritePosition_ = hopSizeActual_ + transformSize_;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new StageDirectorAudioProcessor();
}
